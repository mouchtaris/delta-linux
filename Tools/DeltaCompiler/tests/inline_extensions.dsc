using std;

function transform(ast) {
	local name = <<$TransformerFunc>>;
	local transformerFunc = <<
		function ~name (arg){
			function ToPrimary(ast) {
				local expr = std::ast_new("PrimaryExpression");
				expr.push_back(ast, "expr");
				return expr;
			}
			function ToAST(val) {
				local type = std::typeof(val);
				if (type == std::TYPEOF_NUMBER)
					val = ToPrimary(std::ast_new("NumConst", [@constvalue : val]));
				else if (type == std::TYPEOF_BOOL)
					val = ToPrimary(std::ast_new("BoolConst", [@constvalue : val]));
				else if (type == std::TYPEOF_STRING)
					val = ToPrimary(std::ast_new("StringConst", [@items : std::list_new(val)]));
				else if (type == std::TYPEOF_TABLE or type == std::TYPEOF_OBJECT)
					val = val.ast;	//assume tables generated by the ast_extensions
				return val;
			}
			return ToAST(arg);			
		};
	>>;
	ast.get_child("stmts").push_front(transformerFunc.get_child(0).copy());
	
	local inlineArgs = list_new();
	local visitor = astvisitor_new();
	visitor.set_handler("FunctionCall", function(node, id, entering){
		if (entering) {
			local func = node.get_child("function");
			if (func.get_tag() == "LvalueNamespaceIdent"			and
				func.get_total_children() == 2						and
				func.get_child(0).get_attribute("name") == "std"	and
				func.get_child(1).get_attribute("name") == "inline"
			) {
				inlineArgs.push_back(node.get_child("actuals").get_child(0).get_child(0).get_child(0));	//get the primary expression
				//visitor.leave(); TODO: add this after the astvisitor bug has been fixed
			}
		}
	});
	ast.accept_preorder(visitor);
	foreach(local arg, inlineArgs) {
		local replacement = <<~name(~arg)>>;
		arg.get_parent().replace(arg, replacement.get_child(0).copy());
	}
	return ast;
}