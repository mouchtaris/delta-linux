///////////////////////////////////////////////////////////////////
// Content documents for Delta web site - Metaprogramming.
// Y. Lilis, March 2013.
///////////////////////////////////////////////////////////////////
 
#include "defines.h"

START_DOC("d_metaprogramming", "Metaprogramming"),
index ["Metaprogramming", "Introduction", "Staging annotations", "Stage assembly", "Advanced examples"],

START_SEC("si_metaprogramming_introduction", "Introduction")

TEXT_START

"The term metaprogramming is generally used to denote programs that generate
other programs and was originally related to the existence of a macro system
like the C Preprocessor (CPP) or the Lisp macro system that would allow program 
fragments to be built up at compile-time.
Lexical systems like the CPP are recognized as being inadequate for metaprogramming
as they operate on raw text, unaware of any context information, while most
languages do not share Lisp's syntactic minimalism to provide an equally powerful
facility with seamless integration.",
NL2,
"In modern languages, metaprogramming is closely coupled with functions that operate
on some abstract syntactic form, like an abstract syntax tree (AST), and can be
invoked during compile-time to change existing code or introduce additional code in
the source file that is being compiled. Such functions are called metafunctions and
they as a whole constitute the metaprogram.
The compilation of a program that contains a metaprogram requires the metaprogram
to be executed at compile-time to produce a possibly changed source file that will
then be compiled. If the resulting source contains additional metaprograms they are
executed in the same way until we reach a final source with no metaprograms that 
will be compiled into the final executable. This iterative process may involve
multiple steps of metaprogram evaluations called stages, while languages that support
such a compilation scheme are called multi-stage languages.
Multi-stage languages use special syntax, called staging annotations, to explicitly
specify the evaluation order of the various computations of the program, with respect
to the stage they appear in."

TEXT_END
END_SEC,	// si_metaprogramming_introduction

START_SEC("si_staging_annotations", "Staging annotations")

TEXT_START

"Delta supports multi-stage metaprogramming through the following staging annotations:",
NL2,

!italic !blue !emphatic "Quasi-quotes",
" (written ", !dsrc "<<...>>", ") may be inserted around definitions, such as expressions,
statements, functions, etc., to convey their AST form and are the easiest way (but not the
only one) to create ASTs directly from source text. For instance, ", !dsrc "<<1+2>>", "is the
AST for the source text", !dsrc "1+2", ". Variables within quasi-quotes are scoped in the
context where the respective AST is finally inserted. For instance, ", !dsrc "<<x=1>>",
"does not bind to any", !dsrc "x", "visible at the quasi-quote location. It will bind to an
existing", !dsrc "x", "at the insertion context, or if no", !dsrc "x", "is defined there,
introduce a new", !dsrc "x", "in scope (in Delta variables are declared-by-use). To prevent
variable capture we allow quasi-quotes to introduce alpha-renamed variables (i.e., given
automatically contextually-unique names) using special syntax. In particular,", !dsrc "<<$x>>",
"denotes that", !dsrc "x", "will be given a fresh unique name at the insertion context.
Finally, we allow quasi-quotes to be arbitrarily nested, something useful in higher order 
metaprograms (e.g. when implementing metagenerators). For example,", !dsrc "<< <<1+2>> >>",
"is a nested quasi-quoted expression whose generation produces the quasi-quoted expression",
!dsrc "<<1+2>>", ". Further quasi-quote examples are provided in the code below.",
NL2,

CODE_BLOCK "
x = <<1+2>>;						// x get a value          +
									// representing the     /   \\ 
									// tree on the right   1     2
y = <<1, true, \"str\", [1, 2]>>;	// represents a list of items that can be used
									// as an argument list or as table elements
z = <<								// represents the AST of the entire for loop
	for(i = 0; i < 5; ++i)
		std::print(i);
>>;
u = <<								// represents the AST of the entire function
	function add(x,y)
		{ return x + y; }
>>;
v = <<								// represents a list of statements
	a = 1;
	try {
		while(a > 0) f(a--);
		assert a == 0;
	}
	trap ex { std::print(ex); }
>>;
w = << <<1+2>> >>;					// a nested AST value (AST representing an AST)
q = <<$x = 1>>;						// variable x will not bind to an existing x at the
									// insertion context, but is automatically renamed",

NL2,
!italic !blue !emphatic "Escape",
" (written ", !dsrc "~(expr)", "or", !dsrc "~id", ") is used only within quasi-quotes to prevent converting the
source text of expr into an AST form by evaluating expr normally. Practically, escape is used
on expressions already carrying AST values which need to be combined into an AST constructed
via quasi-quotes. For example, assuming", !dsrc "x", "already carries the AST value of",
!dsrc "<<1>>", ", the expression", !dsrc "<<~x+2>>", "evaluates to", !dsrc "<<1+2>>", ".
Additionally, we also support the escaped expression to carry scalar values like number,
boolean or string (i.e. ground values). In this case, the value is automatically converted to
its corresponding AST value as if it has been a constant. For instance, if", !dsrc "x", "is",
!dsrc "1", ", then", !dsrc "~x", "within", !dsrc "<<~x+2>>", "will be converted to the AST of
value", !dsrc "1", ", or", !dsrc "<<1>>", ", thus", !dsrc "<<~x+2>>", "evaluates to", 
!dsrc "<<1+2>>", ".",
NL2,
"In case of nested quasi-quotes, escapes are evaluated during the construction of the outermost
quasi-quote, meaning that if", !dsrc "x", " is ", !dsrc "<<1>>", ", the expression",
!dsrc "<< <<~x+2>> >>", "evaluates to", !dsrc "<< <<1+2>> >>", ". In order to delay the
evaluation of an escape (something useful in metagenerators), we can use a",
!italic !blue !emphatic "delayed escape", ", denoted as", !dsrc "~...~(expr)", ". For example,
writing", !dsrc "<< <<~~x>> >>", "represents the AST of", !dsrc "<<~x>>", ". The number of
tildes is the initial nesting which for normal escapes is one. Then escape evaluation, being
performed when quasi-quotes are constructed, is applied as follows:",
NL2,
!definition "eval(escape(n, expr) = if n is 1 then expr else escape(n - 1, expr)",
NL2,
"Notice that the previous evaluation is not recursive; it returns either the escaped expression
or a new escape with decreased nesting. Practically, this means that a delayed escape will
eventually be inserted in a generated quasi-quote as a normal escape and then follow its normal
evaluation.",
NL1,
"The code below shows some examples relating to escapes, while examples highlighting the use of
delayed escapes will be discussed once the staging tags and stage assembly are fully explained.", 
NL2,

CODE_BLOCK "
x = <<1>>;
y = <<~x + 2>>;						// y is <<1 + 2>>
z = <<~x + ~y * 3>>;				// z is <<1 + (1 + 2) * 3>>

function id(x) { return x; }
v = <<~(id(1)) + ~(id(2))>>;		// v is <<1 + 2>>

num = 1, str = \"hello\", bool = true;
w = <<~num, ~str, ~bool>>;			// escapses also support ground values, automatically
									// converting them to ASTs, so w is <<1, \"hello\", true>>

function pow(x, n) {				// will generate the AST of multiplying x with itself n times
  if (n == 0)
    return <<1>>;					// termination: just multiply with 1 (in AST form)
  else
    return <<~x * ~(pow(x, n-1))>>;	// recursion: multiply x with the result of the recursive invocation
}

pow3 = pow(<<x>>, 3);				// pow3 is <<x * x * x * 1>>

args = <<2, 3>>;
call1 = <<f(~args)>>;		// call1 is <<f(2, 3)>>
call2 = <<f(1, ~args, 4)>>;	// call2 is <<f(1, 2, 3, 4)>>
call3 = << <<f(~args)>> >>;	// escapes also apply for nested quotes, so call3 is << <<f(2,3)>> >>

t1 = <<[1, ~args, 4]>>;		// t2 is <<[1, 2, 3, 4]>>
empty_ast = nil;			// nil is used to denote an empty AST
t2 = <<[1, ~empty_ast, 4]>>;// escaping a nil value removes the entire node, so t2 is <<[1, 4]>>
call4 = <<f(~empty_ast)>>;	// similarly, call4 is <<f()>>

function func_generator(name, args, body)
	{ return <<function ~name (~args) { ~body; }>>; }

f = func_generator(<<id>>, <<x>>, <<return x;>>);	// f is <<function id(x) { return x; }>>

a = <<$x>>;						// the AST contains variable that will be automatically renamed
b = <<~a + ~a>>;				// such variables are preserved by escapes, so b is <<$x + $x>>

stmts = list_new(				// a list of statements as AST values.
	<<x = 1;>>,					
	<<while(x > 1) f(--x);>>,
	<<assert x == 0;>>
);								// to combine them into a single AST we can do the following:
code = nil;						// initially we have no code, so code is nil
foreach(local stmt, stmts)		// iterate over all statements in the list
	code = <<~code; ~stmt;>>;	// append each statement at the end of the already existing code
								// finally, code is <<
								//			x = 1;
								//			while(x > 1)
								//				f(--x);
								//			assert x == 0;
								//		    >>",

NL2,
!italic !blue !emphatic "Inline",
" (written ", !dsrc "!(expr)", ") evaluates the expr during translation and inserts its result
(that must be of AST type) into the program code by substituting itself, thus performing program
transformation. Inline tags within quasi-quotes are allowed, and as all other quasi-quoted
expressions, are just AST values and are not directly evaluated. It is allowed for expressions
carrying an AST representing an inline directive to be inlined, meaning generation directives
may generate further generation directives, thus supporting metagenerators. The following
examples illustrate the usage of inline.",
NL2,

CODE_BLOCK "
!(<<a = 1>>);						// inserts the statement a = 1 directly into the program source
b = !(<<1+2>>);						// equivalent to b = 1 + 2;
c = !(<<f()>>);						// equivalent to c = f();
function one() { !(<<return 1;>>); }// equivalent to function one() { return 1; }

function id(x) { return x; }
!(id(<<d>>)) = !(id(<<1>>)) + !(id(<<2>>));	// equivalent to d = 1 + 2;

function func_generator(name, args, body)
	{ return <<function ~name (~args) { ~body; }>>; }

!(func_generator(<<add>>, <<x, y>>, <<return x+y;>>));	// will generate the following function:
														// function add(x, y) { return x + y; }
y = !(<<for(i = 0; i < 1; ++i);>>);	// error, generating a statement but expecting expression

function pow(x, n) {
	if (n == 0)
		return <<1>>;
	else
		return <<~x * ~(pow(x, n - 1))>>;
}
print(!(pow(<<2>>, 3)));			// equivalent to print(2 * 2 * 2 * 1);
!(<< print(!(pow(<<2>>, 3))); >>);	// metagenerator for the above statement

function f(n) {
	if (n < 1)
		return nil;
	else
		return <<!(f(~(n - 1)))>>;	// returns an AST that when inlined will cause further staging
}
!(f(10));							// generates !(f(9)) that will then generate !(f(8)) and so on
									// until the last step that eventually generates no code (nil)
									// it involves 10 evaluation rounds (i.e. stages) to complete
function f() { return <<!(f())>>; }
!(f());								// repeatedly generates itself, causing endless staging",

NL2,

!italic !blue !emphatic "Execute",
" (written ", !dsrc "&stmt", ") defines a staged", !dsrc "stmt", "representing any single
statement, local definition or block in the language. Any definitions introduced are visible
only within staged code. As with the other annotations, execute tags can also be quasi-quoted
to be converted to AST form. This means that they are not evaluated directly, but when
inlined they will introduce further staging (metageneration). Examples using execute are shown 
in the code below.",
NL2,

CODE_BLOCK "
&function ExpandPower (n, x) {						// function is available only during compilation
	if (n == 0)
		return <<1>>;
	else
		return <<~x * ~(ExpandPower(n - 1, x))>>;
}
&function MakePower (n)	{							// function is available only during compilation
	return << (
		function (x) { return ~(ExpandPower(n, <<x>>)); }
	)>>;
}
power3 = !(MakePower(3));		// generates: power3 = (function(x){ return x * x * x * 1; });
								// all previous declarations never appear in the final program
&x = <<1>>, y = <<2>>, z = nil;	// x, y, z are available during compilation (compile-time state)
&if (some_condition())			// the if statement is executed during compilation with all
	z = x;						// compile-time state being available to it
 else							// execute tags are also evaluated in order of appearance,
	z = y;						// so they provide the notion of typical control-flow
print(!(z));					// inlines are also evaluated in order and can access compile-time state
								// the generated code depends on the result of the some_condition()
&print(\"hello\");				// executed during compilation, prints 'hello' at compile-time
!(<<&print(\"hello\");>>); 		// metagenerator for the above statement",

"From the staging annotations discussed, quasi-quotes and escape involve no staging but are 
essentially facilities helping programmers in AST manipulation. As shown in the following table,
quasi-quotes are essentially shortcuts for AST creation (ast_create) and escapes involve AST 
composition operations (ast_escape), all handled in our language with internal parser invocations."

TEXT_END,

[ _table(6, 2)
	[ TEXT( !bold !italic "AST tag expressions"), TEXT( !bold !italic "Respective intermediate code")],
	[ TEXT_START !dsrc "<<1 + g()>>;" TEXT_END, TEXT_START !courier "ast_create $0", !dsrc "\"1 + g()\"" TEXT_END],
	[ 	TEXT_START !dsrc "<<~(f(x)) + 2>>;" TEXT_END,
		TEXT_START
			!courier "param x", NL1,
			!courier "call f", NL1,
			!courier "getretval $0", TAB2 !courier !comment "#carries f(x)", NL1,
			!courier "ast_create $1 ", !dsrc "\"~(f(x)) + 2\"", NL1,
			!courier "ast_escape $1 $0", TAB1 !courier !comment "#inserts f(x)"
		TEXT_END
	],
	[ TEXT_START !dsrc "<< << ~~x >> >>" TEXT_END, TEXT_START !courier "ast_create $0", !dsrc "\"<< ~~x >>\"" TEXT_END],
	[ 	TEXT_START !dsrc "<< << ~~x + ~y >> >>" TEXT_END,
		TEXT_START
			!courier "ast_create $0 ", !dsrc "\"<< ~~x + ~y>>\"", NL1,
			!courier "ast_escape $0 y", TAB1 !courier !comment "#inserts y"
		TEXT_END		
	],
	[ 	TEXT_START !dsrc "<<f(~a, ~b)>>" TEXT_END,
		TEXT_START
			!courier "ast_create $0 ", !dsrc "\"f(~a, ~b)\"", NL1,
			!courier "ast_escape $0 a", TAB1 !courier !comment "#inserts a", NL1,
			!courier "ast_escape $0 b", TAB1 !courier !comment "#inserts b"
		TEXT_END
	]
],

TEXT_START

"Inline and execute imply compile-time evaluation of the associated source code, and are essential
in supporting compile-time metaprogramming. Syntactically, they define the boundaries between staged
code fragments and introduce stage nesting. As such, they are also referred to as staging tags.", NL2,

"Both inline and execute tags can also be nested (e.g.", !dsrc "!(!(expr))", "or",
!dsrc "&&&stmt", "), with their nesting depth specifying the exact compilation stage they will
appear in. As a rule of thumb (the exact semantics will be discussed in the following section),
the higher the nesting of inline or execute tags, the sooner they are evaluated during
compilation. This is illustrated in the following example.",

CODE_BLOCK "
!(!(<< <<x = 1>> >>);	// the inner inline is evaluated first generating: !(<<x = 1>>);
						// that is then evaluated to generate the final x = 1;
&print(1);				// the higher the nesting, the sooner the execution, so despite the
&&print(2);				// original order, this will first execute &&&print(3), then &&print(2)
&&&print(3);			// and finally &print(1), meaning the compile-time output is 3, 2, 1"

TEXT_END

END_SEC,	// si_staging_annotations

START_SEC("si_stage_assembly", "Stage assembly")

TEXT_START

"Delta introduces the integrated metaprogramming model, treating distinct meta-code fragments as a single coherent metaprogram.
In this sense, each stage is composed by assembling source fragments from specific staging tags within the main program AST.
Their selection relies on the nesting level of staging tags and reflects two basic rules:", NL1,
!italic !emphatic "(i)", " source fragments of tags with larger nesting depth are evaluated before those of smaller nesting depth", NL1,
!italic !emphatic "(ii)", " source fragments of tags with identical nesting depth are evaluated together in the same stage.", NL1,
"This practically means that to assemble a stage we have to collect all source fragments from the staging tags of the 
maximum nesting depth (i.e. the innermost).", NL2,

"The stage composition begins by traversing the program AST to find its maximum staging nesting.
Then we perform a depth-first traversal and collect all source fragments belonging to staging tags with this maximum nesting.
For execute tags the stmt source is added, and the tag is removed from the main program AST.
This ensures that the specific source fragments only take part in the composition of the current stage.
For inline tags, an ", !dsrc  "std::inline", " call is added with argument the associated expr.
This function is available only during compilation and handles the insertion of source fragments (as ASTs) to the main program AST.
While expr is removed from the main program AST, an orphan inline leaf node is retained so that it can be
used as a marker of the position where the next insertion from ", !dsrc "std::inline", " will occur. 
The latter supports having multiple inlines in the same stage nesting, thus resulting 
in multiple std::inline calls in the stage and orphan inline nodes in the AST.
The ", !dsrc "std::inline", " calls and inline nodes are created during the same traversal so 
that they perfectly match each other during stage evaluation.
", NL2,

"After all source fragments relevant to the current stage are collected, they are assembled
together following their order of appearance in the main program. Then, the resulting program,
that by construction contains no staging tags, is normally compiled to produce the stage binary
which is executed to perform the respective source code transformations.", NL1,

"For example, consider that we have the following source:", NL2,

!emphatic "Original Source",
CODE_BLOCK "
&&function generator(name, args, body)
	{ return << function ~name(~args) { ~body; } >>; }
&!(generator(
	<<const_maker>>,
	<<name, val>>,
	<< return <<function ~~name { return ~~val;}>>; >>
));
!(const_maker(<<one>>, <<1>>));
print(one());
!(const_maker(<<two>>, <<2>>));
print(two());",

"It contains staged code with maximum nesting depth 2, the ", !dsrc "generator", " function and its corresponding invocation.
As previously mentioned, only & and ! tags count towards the nesting depth.", NL1,
"After collecting all source fragments with the maximum nesting depth, the first stage is assembled as:", NL2,

!emphatic "Stage 1 (Nesting depth 2)",
CODE_BLOCK "
function generator(name, args, body)
	{ return <<function ~name(~args) { ~body; }>>; }
std::inline(generator(
	<<const_maker>>,
	<<name, val>>,
	<< return <<function ~~name { return ~~val;}>>; >>
));",

"After compiling and executing the first stage, ", !dsrc "std::inline", " will insert the AST resulting from the ", 
!dsrc "generator", " function invocation, thus transforming the original source as follows. Also notice that the 
entire definition of function ", !dsrc "generator", " has been removed from the transformed source as it was meant
to be available only for the nesting depth 2.", NL2,

!emphatic "Intermediate Source",
CODE_BLOCK "
&function const_maker(name, val)
	{ return <<function ~name { return ~val; }>>; } 
!(const_maker(<<one>>, <<1>>)); 
print(one()); 
!(const_maker(<<two>>, <<2>>)); 
print(two());",

"The transformed source still contains staged code so the staging process continues. Here, the maximum 
nesting depth is 1, present in the definition of function ", !dsrc "const_maker", " and its following
invocations. This way, the second stage is assembled as:", NL2,

!emphatic "Stage 2 (Nesting depth 1)",
CODE_BLOCK "
function const_maker(name, val)
	{ return <<function ~name { return ~val; }>>; }
std::inline(const_maker(<<one>>,<<1>>));
std::inline(const_maker(<<two>>,<<2>>));",

"When executed, the two ", !dsrc "std::inline", "invocations will transform the main AST (and thus the intermediate source version)
by inserting the corresponding ASTs produced by the ", !dsrc "const_maker", " function calls. Each call inserts code directly in the 
location of the original corresponding inline tag. The resulting source is as follows:", NL2,

!emphatic "Final Source",
CODE_BLOCK "
function one { return 1; }
print(one());
function two { return 2; }
print(two());",

"The transformed source contains no further staged code, so it has reached its final form and can be normally 
compiled to produce the final binary. The result of the entire compilation is as though the original program
contained the code shown above.", NL2,

"Apart from the source code insertions performed by the ", !dsrc "std::inline", " invocations, Delta also offers
an additional compile-time function called ", !dsrc "std::context", " that enables metaprograms to obtain and manipulate
the actual context of any inline annotation, thus supporting context-aware generation and transformation. In particular,
the ", !dsrc "std::context", " function locates and returns the orphan inline AST node in which the next inline will actually occur.", NL1,
"For example, consider a class definition with data members for which we wish to automatically generate setter and
getter functions. Instead of separately introducing inline tags for each data member and explicitly supplying their
names, we can utilize ", !dsrc "std::context", " to obtain the AST of the class definition, traverse the AST to obtain
member information and then:", NL1,
!italic !emphatic "(i)", " directly attach to the AST the required method definitions; or ", NL1,
!italic !emphatic "(ii)", " produce the AST for the method definitions, and inline its returned value where desired.", NL1,
"Both options for context-aware code generation are illustrated in the following example.", NL2,

CODE_BLOCK "
&function SettersAndGetters1(class) {
	foreach (local attr, class.getAttributes()) {	 //iterate over class attributes
		local name = attr.getName();
		local setter = <<method ~(\"set_\" + name)(val){self[~name]=val;}>>;
		local getter = <<method ~(\"get_\" + name)(){return self[~name];}>>;
		class.addMethod(setter);	 //add setter and getter methods directly to target class
		class.addMethod(getter);
	}
	return nil;	//no additional code to be inlined in the target class
}
&function SettersAndGetters2(class) {
	local result = nil;  	 //will hold the generated method code tobe inlined in the class 
	foreach (local attr, class.getAttributes()) {	 //iterate over class attributes
		local name = attr.getName();
		local setter = <<method ~(\"set_\" + name)(val){self.~name=val;}>>;
		local getter = <<method ~(\"get_\" + name)(){return self.~name;}>>;
		result = <<~result, ~setter, ~getter>>; // combine methods in a new AST
	}
	return result;	//all setter and getter methods will be inlined in the target class
}
function Point(x, y) {
	return [
		@x : x, @y : y,
		!(SettersAndGetters1(std::context(\"class\")));
		//or !(SettersAndGetters2(std::context(\"class\")));
		//both invocations transform the Point class as shown below:
	];
}
//function Point(x, y) {
//	return [
//		@x : x, @y : y,
//		method set_x(val){ self.x = val;  },
//		method get_x()   { return self.x; },
//		method set_y(val){ self.y = val;  },
//		method get_y()   { return self.y; }
//	];
//}"

TEXT_END

END_SEC,	// si_stage_assembly

START_SEC("si_metaprogramming_examples", "Examples (integrated metaprograms)")

TEXT_START

"We discuss various metaprogram scenarios utilizing basic object-oriented features like encapsulation and
information hiding. Such features may differ from what is typically met in the discussion of a metalanguage,
but they are chosen on purpose to:", NL1,
!italic !emphatic "(i)", " emphasize our point that metaprograms are more than atomic macro expressions", NL1,
!italic !emphatic "(ii)", " highlight the engineering of stages equally to normal programs using shared state and typical control flow.", NL1,
"We don't argue that such examples cannot be expressed in multi-stage languages that do not offer such facilities,
but rather focus on the software engineering advantages gained by adopting the standard programming patterns and
techniques practiced in normal programs. In particular, our examples involve grouping common functionality into
objects available during compilation and utilizing them to transform multiple source code locations without
repeating generation parameters. In a traditional metaprogramming implementation, such examples would have to
adopt separate meta-functions, resulting in a procedural paradigm, while their invocations would typically
involve repetition of the required parameters, as no state sharing is possible (one should also consider that
such parameters are syntactically verbose due to quasi-quotes).", NL2,

!emphatic "Exception Handling", NL1,

"Exception handling is known to be a global design issue that affects multiple system modules. In this sense,
it should be possible to select a specific exception handling policy for the entire system or apply different
policies for different components of the system. This can be achieved through metaprogramming:
We can use meta-functions to abstract the logic for any exception handling pattern and deploy them
to generate the appropriate code at their call sites.", NL2,

"However, without common state across each such invocation is separated from the others and thus requires explicitly
repeating all exception pattern details. Moreover, if multiple exception handling patterns are available, it is not
possible to parameterize their application to form specific exception handling policies. Using integrated metaprograms, 
it is possible to maintain a collection of the available exception handling patterns and select the appropriate policy
based on configuration parameters or normal control flow while requiring no changes at the call sites inside client code.
This is illustrated in the following example.", NL2,

CODE_BLOCK "
&function Logging (stmts)
	{ return << try { ~stmts; } trap e { log(e); } >>; }
&function ConstructRetry (data) {	//constructor for a custom retry policy
	return function (stmts) {		//return a function implementing the code pattern
		return <<					//the returned function returns an AST
			for (local i = 0; i < ~(data.attempts); ++i)
				try { ~stmts; break; }				//try & break loop when successful
				trap e { Sleep(~(data.delay)); } 	//catch & wait before retrying
			if (i == ~(data.attempts)) 				//maximum attempts were tried?
				{ ~(data.failure_stmts); 	} 		//then give-up & invoke failure code
		>>;
	};
}

&Policies = [			//compile-time structure for holding exception policies
	method Install(key, func) {...},
	method Get(key) {...}
];
&Policies.Install(\"LOG\", Logging);			//install the Logging policy
&Policies.Install(\"RETRY\", ConstructRetry([	//create and install a retry policy
	@attempts : 5, @delay : 1000, @fail : <<post(\"FAIL\")>>
]));

&policy = Policies.Get(\"RETRY\");		
!(policy(<<f()>>));				//Generates the code below:
								//for (i = 0; i < 5; ++i)
								//	try { f(); break;  }
								//	trap e { Sleep(1000); }
								//if (i == 5) { post(\"FAIL\"); }
&policy = Policies.Get(\"LOG\");
!(policy(<<g()>>));				//Generates the code below:
								//try { g(); } 
								//catch e { log(e); }",

"The ", !dsrc "Logging", " policy requires no additional information to be expressed while the ",
!dscr "Retry", " policy receives its information (i.e. number of attempts for retrying the operation,
the delay to wait between them in case an exception occurs and code to be executed in case all attempts
fail) as construction parameters. It is important to note that any parameters are required only once upon
construction and are not repeated per policy application. This relieves programmers from repeatedly supplying
the required parameters, but more importantly, it achieves a uniform invocation style, allowing different
policies to be used interchangeably without changes in their call sites. This means that the single ",
!dsrc "!(policy(...));", " invocation can generate any of the available exception handling patterns,
granted that the policy variable has the corresponding value.", NL2,

!emphatic "Design by Contract", NL1,

"Design by Contract (DbyC) is a popular method towards self-checking code that improves software reliability.
It proposes contracts, constituting computable agreements between clients and suppliers.
Clients have to respect method preconditions prior to invocation while suppliers guarantee that the associated
postconditions will be satisfied once the invocation completes. Failure to satisfy the promised obligations, on
either the client or the supplier side, constitutes a contract violation that will most likely result into an error,
typically conveyed as an exception.", NL2,

"In this context, it is possible to use metaprogramming to automatically generate contract verification code.
This applies both for the supplier class, whose methods can be enriched with precondition and postcondition
checking that raise exceptions upon contract failures, and the class clients, whose invocations can be
automatically protected with try-trap blocks. Nevertheless, the definition of the supplier class is separated
from the client invocations, meaning that the applications of the code transformations are also typically
separated. This means that if the transformation logic is not known a priori, i.e. it relies on some prior
compile-time computation, it is not possible to match the generated class definition with a corresponding
generation of the class invocations. Even if the transformation logic is predefined, its applications are still
separated so they may be applied partly, meaning it is possible to end up with a supplier class that uses DbyC
and client invocations that do not or vice versa. In the first case any thrown supplier exception will never be
handled by clients, while in the second case client invocations will contain irrelevant exception handling code
since the supplier class may not throw any contract exceptions.", NL2,

"This problem can be solved with the state sharing and typical control flow offered by integrated metaprograms.
Any transformation to be applied on the supplier class can be stored along with the corresponding transformation
required for its usage and be available in the following stage calls that will generate the client invocations,
taking into account the transformations performed on the class definition. The following code highlights this
functionality, by introducing a single object that can be used to transform both the class definition (through
the ", !dsrc "std::context", " function discussed earlier) and usages. In particular, the transformer object ",
!dsrc "t", " contains all relevant transformation information and could be used to handle any number of classes
along with their usages. Additionally, notice that the inlining code that uses the transformer object is completely 
unaware of the actual transformation being applied; this information is properly encapsulated within the transformer object.", NL2,

CODE_BLOCK "
&function DbyC() {			   				//DbyC transformer
	return [					    		//create and return a transformer object
		method supplier(class) {			//generator for the supplier class
			foreach (local m, class.getMethods()) {	//iterate over class methods
				local pre_id = \"pre_\" + m.getName();//precondition method id
				if (class.hasMethod(pre_id))		//does the precondition method exist?
					m.body.push_front(<<			//add AST at the beginning of the method						
						if (not self[~pre_id]()) 	//has precondition call failed?
							throw [					//then throw an exception
								@class	: \"ContractException\",
								@type	: \"Precondition\",
								@classId: ~(class.getName()),
								@method	: ~(m.getName())
							];>>
					);
					//similar logic to add postcondition checking code at the method end here
				}
				return nil;		//no additional code to be inlined in the supplier context
    },
    method client(invocation_stmts) { 	//generator for the client invocations
    	return <<
         try { ~invocation_stmts; }
         trap ContractException { log(ContractException); }
      >>;
    }
  ];
}
&t = DbyC();	//compile-time transformer object

function Stack() { 
  return [
	  method empty	{...},		//Pop is transformed as follows:
	  method pre_pop{...},		//method pop	{
	  method pop	{...},		//	if (not self[\"pre_pop\"]())
								//		throw [
	!( t.supplier(				//			@class	: \"ContractException\",
	   std::context(\"class\")	//			@type	: \"Precondition\",
 	));							//			@classId: \"Stack\",
								//			@method	: \"pop\"
 ];								//		];
}								//	...original body of pop method here
								//}
st = Stack();
!(t.client(<<st.pop()>>));		//Generates the code below:
								//try { st.pop(); }
								//trap ContractException { log(ContractException); }",

!emphatic "Design patterns", NL1,

"Design patterns constitute generic reusable solutions to commonly recurring problems within a
given context in software design. Effective software design requires considering issues that may
not become visible until later in the implementation and design patterns can help preventing such
problems by providing tested, proven development paradigms. A design pattern is not a complete
design directly transformable into code; it is rather a description on how to solve the given
problem in different situations illustrating relationships and interactions between classes and
objects involved. This means that in general, a pattern has to be re-implemented from scratch each
time it is used, thus significantly reducing the achieved reusability.", NL2,

"Towards this direction, it is possible to utilize metaprogramming to support generating concrete
pattern implementations. The pattern application logic can be expressed as a metaprogram, the concepts
of the pattern can be incorporated as functionality or state present within the metaprogram, while any
information depending on a particular application context can be considered as deployment parameters.
However, such metaprograms may require elaborate programming practices not applicable in a typical metalanguage.", NL2,

"In integrated metaprograms, programmers can apply any typical programming practices like encapsulation,
abstraction and separation of concerns, thus significantly improving the development process.
For example, it is possible to abstract the pattern implementation logic into object-oriented code
generator objects. Additionally, it is possible to have multiple such code generators available (or even
hierarchies of code generators) and being able to select the appropriate one at compile-time based on
the application context without affecting the invocation style used in their deployment. This functionality
is demonstrated in the following example that implements the adapter pattern. The pattern is implemented in
two ways, using delegation and sub-classing, while its application may be parameterized at compile-time.", NL2,

CODE_BLOCK "
&function GetClassDef (target) {...}	//uses compiler state to find the target class 
&function AdapterByDelegation() {   	//creates an adapter object that uses delegation 
	return [
		method adapt (spec) {
			local methods = nil;      		//AST of adapted class methods, initially empty
			local class = GetClassDef(spec.original);
			foreach(local m, class.getMethods()) {  //iterate over class methods
				local name = m.GetName();
				local newName = spec.renames[name];
				if (not newName) newName = name; 	//if no renaming use original name
					methods = <<	//merge existing adapted methods with the current one
						~methods,
						method ~newName (...) { @instance.~name(...); }
					>>;
			}
			return <<  //create and return the adapted class using the adapted methods AST
				function ~(spec.adapted) (...) {
					return [
						@instance : ~(spec.original)(...),
						~methods
					];
				}
			>>;
		}
	];
}
&function AdapterBySubclassing() { //creates an adapter object that uses subclassing
	return [
		method adapt (spec) {
			local adaptedMethods = nil; 	    //AST of methods to be adapted 
			local class = GetClassDef(spec.original);
			foreach(local m, class.getMethods()) {  //iterate over class methods
				local name = m.GetName();
				local newName = spec.renames[name];
				if (newName)	//only check renamed methods, other are inherited by base class
					adaptedMethods = <<  //merge adapted methods with the current one
						~adaptedMethods,
						method ~newName (...) { self.~name(...); }
					>>;
			}
			return <<  //the adapted class as a subclass that introduces the adapted methods
				function ~(spec.adapted)(...) {
					local base = ~(spec.original)(...);  //base class object
					local derived = [~adaptedMethods];   //derived class object
					std::inherit(derived, base); 		//derived object inherits from base
					return derived;
				}
			>>;
		}
	];
}

&AdapterFactory = [    //Creating and populating a factory with adapter implementations
	method Install (type, func) { self[type] = func; },
	method New (type) { return self[type](); }
];
&AdapterFactory.Install(\"delegation\", AdapterByDelegation);
&AdapterFactory.Install(\"subclassing\", AdapterBySubclassing);

&adapterType = \"delegation\";		  //can also be read or computed dynamically
&adapter = AdapterFactory.New(adapterType); 	   //create an adaptor object

function Window(args) { 
	return [
		method Draw() {...},
		method SetWholeScreen() {...},
		method Iconify() {...}
	];
}

&windowAdapterData = [			  //compile-time data for the window adapter
	@original: <<Window>>,
	@adapted : <<WindowAdapter>>,
	@renames : [
		{ \"SetWholeScreen\"	: \"Maximize\" },
		{ \"Iconify\"			: \"Minimize\" }
	]
];

!(adapter.adapt(windowAdapterData));	//Generates the code shown below:
//function WindowAdapter(...) {
//	return [
//		@instance : Window(...),
//		method Draw(...) { @instance.Draw(...); },
//		method Maximize(...) { @instance.SetWholeScreen (...); },
//		method Minimize(...) { @instance.Iconify(...); }
//	];
//}

&adapter = AdapterFactory.New(\"subclassing\");
&windowAdapterData.adapted = <<WindowAdapter2>>;

!(adapter.adapt(windowAdapterData));	//Generates the code shown below:
//function WindowAdapter2(...) {
//	local base = Window(...); 
//	local derived = [
//		method Maximize(...) { self.SetWholeScreen(...); },
//		method Minimize(...) { self.Iconify(...);	}
//	]; 
//	std::inherit(derived, base); 
//	return derived;
//}",

"Such code generator objects can also abstract implementation details of the classes they generate.
This means that such details may be specified only once upon creation and never repeated at each use site.
For instance consider a Singleton class that may adopt different invocation styles (e.g. static functions
or static instance and methods), that may even be declared within a namespace, thus requiring extra syntax
in its usage. Implementing such a code generation scheme in a typical language would require repeating the
generated class details at every inline site something both tiresome (consider that such details are
syntactically verbose due to quasi-quotes) and error-prone. Similarly, updating or replacing such
implementation details (e.g. for refactoring purposes) would require manually locating the affected code
fragments and applying the proper changes for any of them. Below we show an example of abstracting the
implementation details for the definition and usages of a MemoryManager singleton class. In this example,
the singleton class is modeled either through a prototype function or as global data.", NL2,

CODE_BLOCK "
&memoryManagerClass = <<		//basic MemoryManager class implementation
	[
		method Initialize () {...},
		method Cleanup () {...},
		method Allocate (n) {...},
		method Deallocate (var) {...}
	]
>>;
&function GenerateMemoryManagerAsFunction() {
	return [
		@defs : << 
			function MemoryManager() {
				if (not static mm)	  //static initialization idiom
					mm = ~memoryManagerClass;
				return mm;
			}
		>>,
		@init : <<MemoryManager().Initialize()>>,
		@cleanup : <<MemoryManager().Cleanup()>>,
		method alloc(n) { return << MemoryManager().Allocate(~n) >>; },
		method dealloc(var) 
			{ return << MemoryManager().Deallocate(~var) >>;}
	];
}
&function GenerateMemoryManagerAsGlobalData(){ 
	return [
		@defs : <<	mm = ~memoryManagerClass >>,
		@init : <<mm.Initialize()>>,
		@cleanup : <<mm.Cleanup()>>,
		method alloc (n) { return <<mm.Allocate(~n)>>; },
		method dealloc (var) { return <<mm.Deallocate(~var)>>; }
	];
}
&memoryManagerImplementations = [
	@func  : GenerateMemoryManagerAsFunction,
	@global: GenerateMemoryManagerAsGlobalData
];
&option = \"global\";			  	//can also be read or computed dynamically
&mm = memoryManagerImplementations[option]();	//get the generator object

!(mm.defs);					//Generates the code shown below:
							//mm = [
							//	method Initialize () {...},
							//	method Cleanup () {...},
							//	method Allocate (n) {...},
							//	method Deallocate (var) {...}
							//];
//...other normal program definitions...
!(mm.init);					//mm.Initialize();
//...other normal program initializations...
x = !(mm.alloc(<<10>>));	//x = mm.Allocate(10);
//...other normal program code...
!(mm.dealloc(<<x>>));		//mm.Deallocate(x);
//...other normal program cleanups...
!(mm.cleanup);				//mm.Cleanup();",

"As shown, the invocation details are specified only once for each case and are abstracted through
the mm code generator object, allowing matching definition and usage pairs to be automatically
produced without requiring any additional information. The latter allows updating the generation
parameters, possibly affecting names or calling styles, however, without having to change anything
regarding the use of the generated class."

TEXT_END

END_SEC	// si_metaprogramming_examples

END_DOC

///////////////////////////////////////////////////////////////////
